<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 18.5.&nbsp; Terminal Option Flags</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/team.gif" width="60" height="17" border="0" align="absmiddle"  alt="Team BBL"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="ch18lev1sec4.html"><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<a href="ch18lev1sec6.html"><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch18lev1sec5"></a>
<h3 class="docSection1Title" id="454331-862">18.5. Terminal Option Flags</h3>
<p class="docText">In this section, we list all the various terminal option flags, expanding the descriptions of all the options from <a class="docLink" href="ch18lev1sec2.html#ch18fig03">Figures 18.3</a> through <a class="docLink" href="ch18lev1sec2.html#ch18fig06">18.6</a>. This list is alphabetical and indicates in which of the four terminal flag fields the option appears. (The field a given option is controlled by is usually not apparent from the option name alone.) We also note whether each option is defined by the Single UNIX Specification and list the platforms that support it.</P>
<p class="docText">All the flags listed specify one or more bits that we turn on or clear, unless we call the flag a <span class="docEmphasis">mask</span>. A mask defines multiple bits grouped together from which a set of values is defined. We have a defined name for the mask and a name for each value. For <a name="idd1e138059"></a><a name="idd1e138064"></a><a name="idd1e138069"></a><a name="idd1e138074"></a><a name="idd1e138079"></a><a name="idd1e138084"></a><a name="idd1e138089"></a><a name="idd1e138094"></a><a name="idd1e138099"></a><a name="idd1e138102"></a><a name="idd1e138107"></a><a name="idd1e138112"></a><a name="idd1e138117"></a><a name="idd1e138120"></a><a name="idd1e138125"></a><a name="idd1e138130"></a>example, to set the character size, we first zero the bits using the character-size mask <tt>CSIZE</tt>, and then set one of the values <tt>CS5</tt>, <tt>CS6</tt>, <tt>CS7</tt>, or <tt>CS8</tt>.</P>
<p class="docText">The six delay values supported by Linux and Solaris are also masks: <tt>BSDLY</tt>, <tt>CRDLY</tt>, <tt>FFDLY</tt>, <tt>NLDLY</tt>, <tt>TABDLY</tt>, and <tt>VtdLY</tt>. Refer to the <tt>termio</tt>(7I) manual page on Solaris for the length of each delay value. In all cases, a delay mask of 0 means no delay. If a delay is specified, the <tt>OFILL</tt> and <tt>OFDEL</tt> flags determine whether the driver does an actual delay or whether fill characters are transmitted instead.</P>
<a name="ch18ex02"></a>
<H5 class="docExampleTitle">Example</H5>
<p class="docText"><a class="docLink" href="ch18lev1sec5.html#ch18fig11">Figure 18.11</a> demonstrates the use of these masks to extract a value and to set a value.</p>

<a name="ch18fig11"></a>
<H5 class="docExampleTitle">Figure 18.11. Example of <tt>tcgetattr</tt> and <tt>tcsetattr</tt></H5>

<pre>
#include "apue.h"
#include &lt;termios.h&gt;

int
main(void)
{
    struct termios term;

    if (tcgetattr(STDIN_FILENO, &amp;term) &lt; 0)
        err_sys("tcgetattr error");

    switch (term.c_cflag &amp; CSIZE) {
    case CS5:
        printf("5 bits/byte\n");
        break;
    case CS6:
        printf("6 bits/byte\n");
        break;
    case CS7:
        printf("7 bits/byte\n");
        break;
    case CS8:
        printf("8 bits/byte\n");
        break;
    default:
        printf("unknown bits/byte\n");
    }

    term.c_cflag &amp;= <sup>~</sup>CSIZE;     /* zero out the bits */
    term.c_cflag |= CS8;        /* set 8 bits/byte */
    if (tcsetattr(STDIN_FILENO, TCSANOW, &amp;term) &lt; 0)
        err_sys("tcsetattr error");

    exit(0);
}
</pre><BR>


<p class="docText"><a name="idd1e138229"></a><a name="idd1e138234"></a><a name="idd1e138237"></a><a name="idd1e138242"></a><a name="idd1e138247"></a><a name="idd1e138252"></a><a name="idd1e138257"></a><a name="idd1e138262"></a><a name="idd1e138267"></a><a name="idd1e138272"></a><a name="idd1e138277"></a><a name="idd1e138282"></a><a name="idd1e138287"></a><a name="idd1e138292"></a><a name="idd1e138297"></a><a name="idd1e138302"></a><a name="idd1e138307"></a><a name="idd1e138312"></a><a name="idd1e138317"></a><a name="idd1e138322"></a><a name="idd1e138325"></a><a name="idd1e138328"></a><a name="idd1e138333"></a><a name="idd1e138336"></a><a name="idd1e138341"></a><a name="idd1e138344"></a><a name="idd1e138349"></a><a name="idd1e138354"></a><a name="idd1e138359"></a><a name="idd1e138364"></a><a name="idd1e138367"></a><a name="idd1e138372"></a><a name="idd1e138377"></a><a name="idd1e138380"></a>We now describe each of the flags.</p>
<P><table cellspacing="0" FRAME="void" RULES="none" cellpadding="5"><colgroup><col width="150"><col width="350"></colgroup><thead></thead><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>ALTWERASE</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_lflag</tt>, FreeBSD, Mac OS X) If set, an alternate word-erase algorithm is used when the WERASE character is entered. Instead of moving backward until the previous white space character, this flag causes the WERASE character to move backward until the first nonalphanumeric character is encountered.
</P></TD></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>BRKINT</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_iflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If this flag is set and <tt>IGNBRK</tt> is not set, the input and output queues are flushed when a BREAK is received, and a <tt>SIGINT</tt> signal is generated. This signal is generated for the foreground process group if the terminal device is a controlling terminal.
</p></TD></tr><TR><td class="docTableCell" align="left" valign="top">&nbsp;</TD><td class="docTableCell" align="left" valign="top"><p class="docText">If neither <tt>IGNBRK</tt> nor <tt>BRKINT</tt> is set, then a BREAK is read as a single character <tt>\0</tt>, unless <tt>PARMRK</tt> is set, in which case the BREAK is read as the 3-byte sequence <tt>\377</tt>, <tt>\0</tt>, <tt>\0</tt>.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>BSDLY</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_oflag</tt>, XSI, Linux, Solaris) Backspace delay mask. The values for the mask are <tt>BS0</tt> or <tt>BS1</tt>.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>CBAUDEXT</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_cflag</tt>, Solaris) Extended baud rates. Used to enable baud rates greater than B38400. (We discuss baud rates in <a class="docLink" href="ch18lev1sec7.html#ch18lev1sec7">Section 18.7</a>.)
</P></TD></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>CCAR_OFLOW</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_cflag</tt>, FreeBSD, Mac OS X) Enable hardware flow control of the output using the RS-232 modem carrier signal (DCD, known as Data- Carrier-Detect). This is the same as the old <tt>MDMBUF</tt> flag.
</P></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>CCTS_OFLOW</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_cflag</tt>, FreeBSD, Mac OS X, Solaris) Enable hardware flow control of the output using the Clear-To-Send (CTS) RS-232 signal.
</p></TD></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>CDSR_OFLOW</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_cflag</tt>, FreeBSD, Mac OS X) Flow control the output according to the Data-Set-Ready (DSR) RS-232 signal.
</p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>CDTR_IFLOW</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_cflag</tt>, FreeBSD, Mac OS X) Flow control the input according to the Data-Terminal-Ready (DTR) RS-232 signal.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>CIBAUDEXT</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_cflag</tt>, Solaris) Extended input baud rates. Used to enable input baud rates greater than B38400. (We discuss baud rates in <a class="docLink" href="ch18lev1sec7.html#ch18lev1sec7">Section 18.7</a>.)</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>CIGNORE</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_cflag</tt>, FreeBSD, Mac OS X) Ignore control flags.
</P></TD></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>CLOCAL</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_cflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set, the modem status lines are ignored. This usually means that the device is directly attached. When this flag is not set, an <tt>open</tt> of a terminal device usually blocks until the modem answers a call and establishes a connection, for example.
</P></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>CMSPAR</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_oflag</tt>, Linux) Select mark or space parity. If <tt>PARODD</tt> is set, the parity bit is always 1 (mark parity). Otherwise, the parity bit is always 0 (space parity).
</p></TD></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>CRDLY</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_oflag</tt>, XSI, Linux, Solaris) Carriage return delay mask. The values for the mask are <tt>CR0</tt>, <tt>CR1</tt>, <tt>CR2</tt>, or <tt>CR3</tt>.</p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><a name="idd1e138666"></a><a name="idd1e138671"></a><a name="idd1e138676"></a><a name="idd1e138681"></a><a name="idd1e138686"></a><a name="idd1e138691"></a><a name="idd1e138696"></a><a name="idd1e138701"></a><a name="idd1e138706"></a><a name="idd1e138711"></a><a name="idd1e138716"></a><a name="idd1e138721"></a><a name="idd1e138726"></a><a name="idd1e138731"></a><a name="idd1e138736"></a><a name="idd1e138739"></a><a name="idd1e138742"></a><a name="idd1e138747"></a><a name="idd1e138750"></a><tt>CREAD</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_cflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set, the receiver is enabled, and characters can be received.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>CRTSCTS</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_cflag</tt>, FreeBSD, Linux, Mac OS X, Solaris) Behavior depends on platform. For Solaris, enables outbound hardware flow control if set. On the other three platforms, enables both inbound and outbound hardware flow control (equivalent to <tt>CCTS_OFLOW|CRTS_IFLOW</tt>).
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>CRTS_IFLOW</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_cflag</tt>, FreeBSD, Mac OS X, Solaris) Request-To-Send (RTS) flow control of input.
</P></TD></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>CRTSXOFF</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_cflag</tt>, Solaris) If set, inbound hardware flow control is enabled. The state of the Request-To-Send RS-232 signal controls the flow control.</P>
</TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>CSIZE</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_cflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) This field is a mask that specifies the number of bits per byte for both transmission and reception. This size does not include the parity bit, if any. The values for the field defined by this mask are <tt>CS5</tt>, <tt>CS6</tt>, <tt>CS7</tt>, and <tt>CS8</tt>, for 5, 6, 7, and 8 bits per byte, respectively.
</p></TD></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>CSTOPB</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_cflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set, two stop bits are used; otherwise, one stop bit is used.
</p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>ECHO</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_lflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set, input characters are echoed back to the terminal device. Input characters can be echoed in either canonical or noncanonical mode.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>ECHOCTL</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_lflag</tt>, FreeBSD, Linux, Mac OS X, Solaris) If set and if <tt>ECHO</tt> is set, ASCII control characters (those characters in the range 0 through octal 37, inclusive) other than the ASCII TAB, the ASCII NL, and the START and STOP characters are echoed as <sup>^</sup><span class="docEmphasis">X</span>, where <span class="docEmphasis">X</span> is the character formed by adding octal 100 to the control character. This means that the ASCII Control-A character (octal 1) is echoed as <tt>^A</tt>. Also, the ASCII DELETE character (octal 177) is echoed as <tt>^?</tt>. If this flag is not set, the ASCII control characters are echoed as themselves. As with the <tt>ECHO</tt> flag, this flag affects the echoing of control characters in both canonical and noncanonical modes.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText">Be aware that some systems echo the EOF character differently, since its typical value is Control-D. (Control-D is the ASCII EOT character, which can cause some terminals to hang up.) Check your manual.
</p></TD></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>ECHOE</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_lflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set and if <tt>ICANON</tt> is set, the ERASE character erases the last character in the current line from the display. This is usually done in the terminal driver by writing the three-character sequence backspace, space, backspace.
</P></TD></TR><tr><TD class="docTableCell" align="left" valign="top">&nbsp;</td><TD class="docTableCell" align="left" valign="top"><p class="docText">If the WERASE character is supported, <tt>ECHOE</tt> causes the previous word to be erased using one or more of the same three-character sequence.
</P></TD></tr><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</td><TD class="docTableCell" align="left" valign="top"><p class="docText">If the <tt>ECHOPRT</tt> flag is supported, the actions described here for <tt>ECHOE</tt> assume that the <tt>ECHOPRT</tt> flag is not set.</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><a name="idd1e138967"></a><a name="idd1e138970"></a><a name="idd1e138975"></a><a name="idd1e138980"></a><a name="idd1e138985"></a><a name="idd1e138988"></a><a name="idd1e138991"></a><a name="idd1e138996"></a><a name="idd1e139001"></a><a name="idd1e139006"></a><a name="idd1e139011"></a><a name="idd1e139016"></a><a name="idd1e139021"></a><a name="idd1e139024"></a><a name="idd1e139027"></a><a name="idd1e139030"></a><a name="idd1e139033"></a><a name="idd1e139036"></a><a name="idd1e139039"></a><a name="idd1e139042"></a><tt>ECHOK</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_lflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set and if <tt>ICANON</tt> is set, the KILL character erases the current line from the display or outputs the NL character (to emphasize that the entire line was erased).
</p></TD></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText">If the <tt>ECHOKE</tt> flag is supported, this description of <tt>ECHOK</tt> assumes that <tt>ECHOKE</tt> is not set.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>ECHOKE</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_lflag</tt>, FreeBSD, Linux, Mac OS X, Solaris) If set and if <tt>ICANON</tt> is set, the KILL character is echoed by erasing each character on the line. The way in which each character is erased is selected by the <tt>ECHOE</tt> and <tt>ECHOPRT</tt> flags.
</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>ECHONL</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_lflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set and if <tt>ICANON</tt> is set, the NL character is echoed, even if <tt>ECHO</tt> is not set.
</P></TD></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>ECHOPRT</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_lflag</tt>, FreeBSD, Linux, Mac OS X, Solaris) If set and if both <tt>ICANON</tt> and <tt>ECHO</tt> are set, then the ERASE character (and WERASE character, if supported) cause all the characters being erased to be printed as they are erased. This is often useful on a hard-copy terminal to see exactly which characters are being deleted.
</p></TD></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EXTPROC</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_lflag</tt>, FreeBSD, Mac OS X) If set, canonical character processing is performed external to the operating system. This can be the case if the serial communication peripheral card can offload the host processor by doing some of the line discipline processing. This can also be the case when using pseudo terminals (<a class="docLink" href="ch19.html#ch19">Chapter 19</a>).
</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>FFDLY</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_oflag</tt>, XSI, Linux, Solaris) Form feed delay mask. The values for the mask are <tt>FF0</tt> or <tt>FF1</tt>.
</P></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>FLUSHO</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_lflag</tt>, FreeBSD, Linux, Mac OS X, Solaris) If set, output is being flushed. This flag is set when we type the DISCARD character; the flag is cleared when we type another DISCARD character. We can also set or clear this condition by setting or clearing this terminal flag.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>HUPCL</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_cflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set, the modem control lines are lowered (i.e., the modem connection is broken) when the last process closes the device.
</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>ICANON</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_lflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set, canonical mode is in effect (<a class="docLink" href="ch18lev1sec10.html#ch18lev1sec10">Section 18.10</a>). This enables the following characters: EOF, EOL, EOL2, ERASE, KILL, REPRINT, STATUS, and WERASE. The input characters are assembled into lines.
</P></TD></tr><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><td class="docTableCell" align="left" valign="top"><p class="docText">If canonical mode is not enabled, read requests are satisfied directly from the input queue. A read does not return until at least MIN bytes have been received or the timeout value TIME has expired between bytes. Refer to <a class="docLink" href="ch18lev1sec11.html#ch18lev1sec11">Section 18.11</a> for additional details.</P></td></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><a name="idd1e139250"></a><a name="idd1e139253"></a><a name="idd1e139258"></a><a name="idd1e139261"></a><a name="idd1e139266"></a><a name="idd1e139271"></a><a name="idd1e139276"></a><a name="idd1e139281"></a><a name="idd1e139286"></a><a name="idd1e139291"></a><a name="idd1e139296"></a><a name="idd1e139301"></a><a name="idd1e139304"></a><a name="idd1e139309"></a><a name="idd1e139314"></a><a name="idd1e139319"></a><a name="idd1e139322"></a><a name="idd1e139327"></a><a name="idd1e139332"></a><a name="idd1e139335"></a><a name="idd1e139340"></a><a name="idd1e139343"></a><tt>ICRNL</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_iflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set and if <tt>IGNCR</tt> is not set, a received CR character is translated into a NL character.
</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>IEXTEN</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_lflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set, the extended, implementation-defined special characters are recognized and processed.
</p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>IGNBRK</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_iflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) When set, a BREAK condition on input is ignored. See <tt>BRKINT</tt> for a way to have a BREAK condition either generate a <tt>SIGINT</tt> signal or be read as data.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>IGNCR</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_iflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set, a received CR character is ignored. If this flag is not set, it is possible to translate the received CR into a NL character if the <tt>ICRNL</tt> flag is set.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>IGNPAR</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_iflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) When set, an input byte with a framing error (other than a BREAK) or an input byte with a parity error is ignored.
</P></TD></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>IMAXBEL</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_iflag</tt>, FreeBSD, Linux, Mac OS X, Solaris) Ring bell when input queue is full.
</P></td></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>INLCR</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_iflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set, a received NL character is translated into a CR character.
</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>INPCK</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_iflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) When set, input parity checking is enabled. If <tt>INPCK</tt> is not set, input parity checking is disabled.
</p></TD></tr><TR><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText">Parity &quot;generation and detection&quot; and &quot;input parity checking&quot; are two different things. The generation and detection of parity bits is controlled by the <tt>PARENB</tt> flag. Setting this flag usually causes the device driver for the serial interface to generate parity for outgoing characters and to verify the parity of incoming characters. The flag <tt>PARODD</tt> determines whether the parity should be odd or even. If an input character arrives with the wrong parity, then the state of the <tt>INPCK</tt> flag is checked. If this flag is set, then the <tt>IGNPAR</tt> flag is checked (to see whether the input byte with the parity error should be ignored); if the byte should not be ignored, then the <tt>PARMRK</tt> flag is checked to see what characters should be passed to the reading process.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>ISIG</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_lflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set, the input characters are compared against the special characters that cause the terminal-generated signals to be generated (INTR, QUIT, SUSP, and DSUSP); if equal, the corresponding signal is generated.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>ISTRIP</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_iflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) When set, valid input bytes are stripped to 7 bits. When this flag is not set, all 8 bits are processed.</p></TD></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><a name="idd1e139538"></a><a name="idd1e139543"></a><a name="idd1e139548"></a><a name="idd1e139553"></a><a name="idd1e139558"></a><a name="idd1e139561"></a><a name="idd1e139566"></a><a name="idd1e139571"></a><a name="idd1e139576"></a><a name="idd1e139581"></a><a name="idd1e139586"></a><a name="idd1e139589"></a><a name="idd1e139594"></a><a name="idd1e139599"></a><a name="idd1e139604"></a><a name="idd1e139609"></a><a name="idd1e139614"></a><a name="idd1e139619"></a><a name="idd1e139624"></a><a name="idd1e139629"></a><a name="idd1e139634"></a><a name="idd1e139639"></a><a name="idd1e139644"></a><a name="idd1e139649"></a><a name="idd1e139654"></a><a name="idd1e139657"></a><a name="idd1e139660"></a><a name="idd1e139663"></a><a name="idd1e139668"></a><a name="idd1e139673"></a><tt>IUCLC</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_iflag</tt>, Linux, Solaris) Map uppercase to lowercase on input.
</p></TD></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>IXANY</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_iflag</tt>, XSI, FreeBSD, Linux, Mac OS X, Solaris) Enable any characters to restart output.
</P></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>IXOFF</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_iflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set, startstop input control is enabled. When it notices that the input queue is getting full, the terminal driver outputs a STOP character. This character should be recognized by the device that is sending the data and cause the device to stop. Later, when the characters on the input queue have been processed, the terminal driver will output a START character. This should cause the device to resume sending data.
</P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>IXON</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_iflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set, startstop output control is enabled. When the terminal driver receives a STOP character, output stops. While the output is stopped, the next START character resumes the output. If this flag is not set, the START and STOP characters are read by the process as normal characters.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>MDMBUF</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_cflag</tt>, FreeBSD, Mac OS X) Flow control the output according to the modem carrier flag. This is the old name for the <tt>CCAR_OFLOW</tt> flag.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>NLDLY</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_oflag</tt>, XSI, Linux, Solaris) Newline delay mask. The values for the mask are <tt>NL0</tt> or <tt>NL1</tt>.
</p></TD></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>NOFLSH</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_lflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) By default, when the terminal driver generates the <tt>SIGINT</tt> and <tt>SIGQUIT</tt> signals, both the input and output queues are flushed. Also, when it generates the <tt>SIGSUSP</tt> signal, the input queue is flushed. If the <tt>NOFLSH</tt> flag is set, this normal flushing of the queues does not occur when these signals are generated.
</p></TD></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>NOKERNINFO</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_lflag</tt>, FreeBSD, Mac OS X) When set, this flag prevents the STATUS character from printing information on the foreground process group. Regardless of this flag, however, the STATUS character still causes the <tt>SIGINFO</tt> signal to be sent to the foreground process group.
</P></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>OCRNL</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_oflag</tt>, XSI, FreeBSD, Linux, Solaris) If set, map CR to NL on output.
</P></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>OFDEL</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_oflag</tt>, XSI, Linux, Solaris) If set, the output fill character is ASCII DEL; otherwise, it's ASCII NUL. See the <tt>OFILL</tt> flag.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>OFILL</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_oflag</tt>, XSI, Linux, Solaris) If set, fill characters (either ASCII DEL or ASCII NUL; see the <tt>OFDEL</tt> flag) are transmitted for a delay, instead of using a timed delay. See the six delay masks: <tt>BSDLY</tt>, <tt>CRDLY</tt>, <tt>FFDLY</tt>, <tt>NLDLY</tt>, <tt>TABDLY</tt>, and <tt>VtdLY</tt>.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>OLCUC</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_oflag</tt>, Linux, Solaris) If set, map lowercase characters to uppercase characters on output.</P></TD></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><a name="idd1e139905"></a><a name="idd1e139908"></a><a name="idd1e139913"></a><a name="idd1e139918"></a><a name="idd1e139923"></a><a name="idd1e139928"></a><a name="idd1e139933"></a><a name="idd1e139938"></a><a name="idd1e139943"></a><a name="idd1e139948"></a><a name="idd1e139953"></a><a name="idd1e139958"></a><a name="idd1e139963"></a><a name="idd1e139968"></a><a name="idd1e139973"></a><a name="idd1e139978"></a><a name="idd1e139983"></a><a name="idd1e139986"></a><a name="idd1e139991"></a><tt>ONLCR</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_oflag</tt>, XSI, FreeBSD, Linux, Mac OS X, Solaris) If set, map NL to CR-NL on output.
</P></td></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>ONLRET</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_oflag</tt>, XSI, FreeBSD, Linux, Solaris) If set, the NL character is assumed to perform the carriage return function on output.
</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>ONOCR</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_oflag</tt>, XSI, FreeBSD, Linux, Solaris) If set, a CR is not output at column 0.
</p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>ONOEOT</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_oflag</tt>, FreeBSD, Mac OS X) If set, EOT (^D) characters are discarded on output. This may be necessary on some terminals that interpret the Control-D as a hangup.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>OPOST</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_oflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set, implementation-defined output processing takes place. Refer to <a class="docLink" href="ch18lev1sec2.html#ch18fig06">Figure 18.6</a> for the various implementation-defined flags for the <tt>c_oflag</tt> word.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>OXTABS</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_oflag</tt>, FreeBSD, Mac OS X) If set, tabs are expanded to spaces on output. This produces the same effect as setting the horizontal tab delay (<tt>TABDLY</tt>)to <tt>XTABS</tt> or <tt>TAB3</tt>.
</P></TD></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>PARENB</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_cflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set, parity generation is enabled for outgoing characters, and parity checking is performed on incoming characters. The parity is odd if <tt>PARODD</tt> is set; otherwise, it is even parity. See also the discussion of the <tt>INPCK</tt>, <tt>IGNPAR</tt>, and <tt>PARMRK</tt> flags.
</P></td></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>PAREXT</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_cflag</tt>, Solaris) Select mark or space parity. If <tt>PARODD</tt> is set, the parity bit is always 1 (mark parity). Otherwise, the parity bit is always 0 (space parity).
</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>PARMRK</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_iflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) When set and if <tt>IGNPAR</tt> is not set, a byte with a framing error (other than a BREAK) or a byte with a parity error is read by the process as the three-character sequence <tt>\377</tt>, <tt>\0</tt>, <span class="docEmphasis">X</span>, where <span class="docEmphasis">X</span> is the byte received in error. If <tt>ISTRIP</tt> is not set, a valid <tt>\377</tt> is passed to the process as <tt>\377</tt>, <tt>\377</tt>. If neither <tt>IGNPAR</tt> nor <tt>PARMRK</tt> is set, a byte with a framing error (other than a BREAK) or with a parity error is read as a single character <tt>\0</tt>.
</p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>PARODD</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_cflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set, the parity for outgoing and incoming characters is odd parity. Otherwise, the parity is even parity. Note that the <tt>PARENB</tt> flag controls the generation and detection of parity.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText">The <tt>PARODD</tt> flag also controls whether mark or space parity is used when either the <tt>CMSPAR</tt> or <tt>PAREXT</tt> flag is set.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>PENDIN</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_lflag</tt>, FreeBSD, Linux, Mac OS X, Solaris) If set, any input that has not been read is reprinted by the system when the next character is input. This action is similar to what happens when we type the REPRINT character.</p></TD></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><a name="idd1e140250"></a><a name="idd1e140255"></a><a name="idd1e140260"></a><a name="idd1e140265"></a><a name="idd1e140270"></a><a name="idd1e140275"></a><a name="idd1e140280"></a><a name="idd1e140285"></a><a name="idd1e140290"></a><a name="idd1e140295"></a><a name="idd1e140300"></a><a name="idd1e140305"></a><a name="idd1e140310"></a><a name="idd1e140315"></a><a name="idd1e140320"></a><tt>TABDLY</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_oflag</tt>, XSI, Linux, Solaris) Horizontal tab delay mask. The values for the mask are <tt>TAB0</tt>, <tt>TAB1</tt>, <tt>TAB2</tt>, or <tt>TAB3</tt>.
</p></TD></tr><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><td class="docTableCell" align="left" valign="top"><p class="docText">The value <tt>XTABS</tt> is equal to <tt>TAB3</tt>. This value causes the system to expand tabs into spaces. The system assumes a tab stop every eight spaces, and we can't change this assumption.
</P></TD></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>TOSTOP</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_lflag</tt>, POSIX.1, FreeBSD, Linux, Mac OS X, Solaris) If set and if the implementation supports job control, the <tt>SIGTTOU</tt> signal is sent to the process group of a background process that tries to write to its controlling terminal. By default, this signal stops all the processes in the process group. This signal is not generated by the terminal driver if the background process that is writing to the controlling terminal is either ignoring or blocking the signal.
</p></TD></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>VTDLY</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_oflag</tt>, XSI, Linux, Solaris) Vertical tab delay mask. The values for the mask are <tt>VT0</tt> or <tt>VT1</tt>.
</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>XCASE</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(<tt>c_lflag</tt>, Linux, Solaris) If set and if <tt>ICANON</tt> is also set, the terminal is assumed to be uppercase only, and all input is converted to lowercase. To input an uppercase character, precede it with a backslash. Similarly, an uppercase character is output by the system by being preceded by a backslash. (This option flag is obsolete today, since most, if not all, uppercase-only terminals have disappeared.)</p></td></tr></table></p><br>

<ul></UL></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/team.gif" width="60" height="17" border="0" align="absmiddle"  alt="Team BBL"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="ch18lev1sec4.html"><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<a href="ch18lev1sec6.html"><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>