<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 15.10.&nbsp; ClientServer Properties</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/team.gif" width="60" height="17" border="0" align="absmiddle"  alt="Team BBL"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="ch15lev1sec9.html"><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<a href="ch15lev1sec11.html"><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch15lev1sec10"></a>
<h3 class="docSection1Title" id="454331-830">15.10. ClientServer Properties</h3>
<p class="docText"><a name="idd1e117861"></a><a name="idd1e117866"></a><a name="idd1e117871"></a><a name="idd1e117876"></a><a name="idd1e117881"></a><a name="idd1e117886"></a><a name="idd1e117891"></a><a name="idd1e117896"></a><a name="idd1e117901"></a><a name="idd1e117906"></a><a name="idd1e117909"></a>Let's detail some of the properties of clients and servers that are affected by the various types of IPC used between them. The simplest type of relationship is to have the client <tt>fork</tt> and <tt>exec</tt> the desired server. Two half-duplex pipes can be created before the <tt>fork</tt> to allow data to be transferred in both directions. <a class="docLink" href="ch15lev1sec4.html#ch15fig16">Figure 15.16</a> is an example of this. The server that is executed can be a set-user-ID program, giving it special privileges. Also, the server can determine the real identity of the client by looking at its real user ID. (Recall from <a class="docLink" href="ch08lev1sec10.html#ch08lev1sec10">Section 8.10</a> that the real user ID and real group ID don't change across an <tt>exec</tt>.)</P>
<p class="docText">With this arrangement, we can build an <span class="docEmphasis">open server</span>. (We show an implementation of this clientserver in <a class="docLink" href="ch17lev1sec5.html#ch17lev1sec5">Section 17.5</a>.) It opens files for the client instead of the client calling the <tt>open</tt> function. This way, additional permission checking can be added, above and beyond the normal UNIX system user/group/other permissions. We assume that the server is a set-user-ID program, giving it additional permissions (root permission, perhaps). The server uses the real user ID of the client to determine whether to give it access to the requested file. This way, we can build a server that allows certain users permissions that they don't normally have.</P>
<p class="docText">In this example, since the server is a child of the parent, all the server can do is pass back the contents of the file to the parent. Although this works fine for regular files, it can't be used for special device files, for example. We would like to be able to have the server open the requested file and pass back the file descriptor. Whereas a parent can pass a child an open descriptor, a child cannot pass a descriptor back to the parent (unless special programming techniques are used, which we cover in <a class="docLink" href="ch17.html#ch17">Chapter 17</a>).</p>
<p class="docText">We showed the next type of server in <a class="docLink" href="ch15lev1sec5.html#ch15fig23">Figure 15.23</a>. The server is a daemon process that is contacted using some form of IPC by all clients. We can't use pipes for this type of clientserver. A form of named IPC is required, such as FIFOs or message queues. With FIFOs, we saw that an individual per client FIFO is also required if the server is to send data back to the client. If the clientserver application sends data only from the client to the server, a single well-known FIFO suffices. (The System V line printer spooler used this form of clientserver arrangement. The client was the <tt>lp</tt>(1) command, and the server was the <tt>lpsched</tt> daemon process. A single FIFO was used, since the flow of data was only from the client to the server. Nothing was sent back to the client.)</P>
<p class="docText">Multiple possibilities exist with message queues.</P>
<div style="font-weight:bold"><ol class="docList" type="1"><LI><div style="font-weight:normal"><p class="docList">A single queue can be used between the server and all the clients, using the type field of each message to indicate the message recipient. For example, the clients can send their requests with a type field of 1. Included in the request must be the client's process ID. The server then sends the response with the type field set to the client's process ID. The server receives only the messages with a type field of 1 (the fourth argument for <tt>msgrcv</tt>), and the clients receive only the messages with a type field equal to their process IDs.</p></div></LI><LI><div style="font-weight:normal"><p class="docList">Alternatively, an individual message queue can be used for each client. Before sending the first request to a server, each client creates its own message queue <a name="idd1e117986"></a><a name="idd1e117991"></a><a name="idd1e117996"></a><a name="idd1e118001"></a><a name="idd1e118006"></a><a name="idd1e118011"></a><a name="idd1e118016"></a><a name="idd1e118021"></a>with a key of <tt>IPC_PRIVATE</tt>. The server also has its own queue, with a key or identifier known to all clients. The client sends its first request to the server's well-known queue, and this request must contain the message queue ID of the client's queue. The server sends its first response to the client's queue, and all future requests and responses are exchanged on this queue.</P><p class="docList">One problem with this technique is that each client-specific queue usually has only a single message on it: a request for the server or a response for a client. This seems wasteful of a limited systemwide resource (a message queue), and a FIFO can be used instead. Another problem is that the server has to read messages from multiple queues. Neither <tt>select</tt> nor <tt>poll</tt> works with message queues.</p></div></LI></ol></div>
<p class="docText">Either of these two techniques using message queues can be implemented using shared memory segments and a synchronization method (a semaphore or record locking).</p>
<p class="docText">The problem with this type of clientserver relationship (the client and the server being unrelated processes) is for the server to identify the client accurately. Unless the server is performing a nonprivileged operation, it is essential that the server know who the client is. This is required, for example, if the server is a set-user-ID program. Although all these forms of IPC go through the kernel, there is no facility provided by them to have the kernel identify the sender.</P>
<p class="docText">With message queues, if a single queue is used between the client and the server (so that only a single message is on the queue at a time, for example), the <tt>msg_lspid</tt> of the queue contains the process ID of the other process. But when writing the server, we want the effective user ID of the client, not its process ID. There is no portable way to obtain the effective user ID, given the process ID. (Naturally, the kernel maintains both values in the process table entry, but other than rummaging around through the kernel's memory, we can't obtain one, given the other.)</P>
<p class="docText">We'll use the following technique in <a class="docLink" href="ch17lev1sec3.html#ch17lev1sec3">Section 17.3</a> to allow the server to identify the client. The same technique can be used with FIFOs, message queues, semaphores, or shared memory. For the following description, assume that FIFOs are being used, as in <a class="docLink" href="ch15lev1sec5.html#ch15fig23">Figure 15.23</a>. The client must create its own FIFO and set the file access permissions of the FIFO so that only user-read and user-write are on. We assume that the server has superuser privileges (or else it probably wouldn't care about the client's true identity), so the server can still read and write to this FIFO. When the server receives the client's first request on the server's well-known FIFO (which must contain the identity of the client-specific FIFO), the server calls either <tt>stat</tt> or <tt>fstat</tt> on the client-specific FIFO. The server assumes that the effective user ID of the client is the owner of the FIFO (the <tt>st_uid</tt> field of the <tt>stat</tt> structure). The server verifies that only the user-read and user-write permissions are enabled. As another check, the server should also look at the three times associated with the FIFO (the <tt>st_atime</tt>, <tt>st_mtime</tt>, and <tt>st_ctime</tt> fields of the <tt>stat</tt> structure) to verify that they are recent (no older than 15 or 30 seconds, for example). If a malicious client can create a FIFO with someone else as the owner and set the file's permission bits to user-read and user-write only, then the system has other fundamental security problems.</P>
<p class="docText"><a name="idd1e118091"></a><a name="idd1e118096"></a><a name="idd1e118101"></a><a name="idd1e118106"></a><a name="idd1e118111"></a><a name="idd1e118116"></a><a name="idd1e118121"></a><a name="idd1e118124"></a><a name="idd1e118129"></a><a name="idd1e118134"></a><a name="idd1e118139"></a><a name="idd1e118142"></a><a name="idd1e118147"></a><a name="idd1e118152"></a>To use this technique with XSI IPC, recall that the <tt>ipc_perm</tt> structure associated with each message queue, semaphore, and shared memory segment identifies the creator of the IPC structure (the <tt>cuid</tt> and <tt>cgid</tt> fields). As with the example using FIFOs, the server should require the client to create the IPC structure and have the client set the access permissions to user-read and user-write only. The times associated with the IPC structure should also be verified by the server to be recent (since these IPC structures hang around until explicitly deleted).</p>
<p class="docText">We'll see in <a class="docLink" href="ch17lev1sec2.html#ch17lev2sec2">Section 17.2.2</a> that a far better way of doing this authentication is for the kernel to provide the effective user ID and effective group ID of the client. This is done by the STREAMS subsystem when file descriptors are passed between processes.</P>

<UL></ul></TD></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/team.gif" width="60" height="17" border="0" align="absmiddle"  alt="Team BBL"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="ch15lev1sec9.html"><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<a href="ch15lev1sec11.html"><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>