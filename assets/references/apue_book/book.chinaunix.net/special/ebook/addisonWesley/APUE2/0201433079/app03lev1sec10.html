<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Chapter 10</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/team.gif" width="60" height="17" border="0" align="absmiddle"  alt="Team BBL"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="app03lev1sec9.html"><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<a href="app03lev1sec11.html"><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="app03lev1sec10"></a>
<h3 class="docSection1Title">Chapter 10</h3>
<p class="docText"></P>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch10qa1q1a1"></a><B><a class="docLink" href="ch10lev1sec23.html#ch10qa1q1">10.1</a></b></TD><td><p class="docText"><a name="idd1e81363"></a><a name="idd1e81368"></a><a name="idd1e81373"></a><a name="idd1e81378"></a><a name="idd1e81381"></a><a name="idd1e81386"></a><a name="idd1e81391"></a><a name="idd1e81396"></a><a name="idd1e81399"></a><a name="idd1e81404"></a><a name="idd1e81409"></a><a name="idd1e81412"></a><a name="idd1e81417"></a>The program terminates the first time we send it a signal. The reason is that the <tt>pause</tt> function returns whenever a signal is caught.</P></TD></TR><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch10qa1q3a3"></a><b><a class="docLink" href="ch10lev1sec23.html#ch10qa1q3">10.3</a></b></TD><TD><p class="docText"><a class="docLink" href="app03lev1sec10.html#app03fig10">Figure C.10</a> shows the stack frames.</P>
<a name="app03fig10"></a><p><center>
<H5 class="docFigureTitle">Figure C.10. Stack frames before and after <tt>longjmp</tt></H5>
<p class="docText"><div class="v1"><a target="_self" href="images/0201433079/graphics/xcfig10_alt.gif;423615">[View full size image]</a></div><img border="0" alt="" id="195131139046" width="500" height="204" SRC="images/0201433079/graphics/xcfig10.gif;423615"></p>
</center></P><BR>
<p class="docText">The <tt>longjmp</tt> from <tt>sig_alrm</tt> back to <tt>main</tt> effectively aborts the call to <tt>sig_int</tt>.</p></td></tr><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch10qa1q4a4"></a><b><a class="docLink" href="ch10lev1sec23.html#ch10qa1q4">10.4</a></b></TD><td><p class="docText">We again have a race condition, this time between the first call to <tt>alarm</tt> and the call to <tt>setjmp</tt>. If the process is blocked by the kernel between these two function calls, the alarm goes off, the signal handler is called, and <tt>longjmp</tt> is called. But since <tt>setjmp</tt> was never called, the buffer <tt>env_alrm</tt> is not set. The operation of <tt>longjmp</tt> is undefined if its jump buffer has not been initialized by <tt>setjmp</tt>.</P></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa1q5a5"></a><b><a class="docLink" href="ch10lev1sec23.html#ch10qa1q5">10.5</a></b></td><td><p class="docText">See &quot;Implementing Software Timers&quot; by Don Libes (<span class="docEmphasis">C Users Journal</span>, vol. 8, no. 11, Nov. 1990) for an example.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa1q7a7"></a><b><a class="docLink" href="ch10lev1sec23.html#ch10qa1q7">10.7</a></b></td><td><p class="docText">If we simply called <tt>_exit</tt>, the termination status of the process would not show that it was terminated by the <tt>SIGABRT</tt> signal.</p></td></TR><TR valign="top"><td align="right" class="docText" width="50"><a name="ch10qa1q8a8"></a><B><a class="docLink" href="ch10lev1sec23.html#ch10qa1q8">10.8</a></b></TD><TD><p class="docText">If the signal was sent by a process owned by some other user, the process has to be set-user-ID to either root or to the owner of the receiving process, or the <tt>kill</tt> won't work. Therefore, the real user ID provides more information to the receiver of the signal.</p></TD></TR><TR valign="top"><td align="right" class="docText" width="50"><a name="ch10qa1q10a10"></a><B><a class="docLink" href="ch10lev1sec23.html#ch10qa1q10">10.10</a></b></td><TD><p class="docText">On one system used by the author, the value for the number of seconds increased by 1 about every 6090 minutes. This skew occurs because each call to <tt>sleep</tt> schedules an event for a time in the future, but is not awakened exactly when that event occurs (because of CPU scheduling). In addition, a finite amount of time is required for our process to start running and call <tt>sleep</tt> again.</P>
<p class="docText"><a name="idd1e81830"></a><a name="idd1e81835"></a><a name="idd1e81840"></a><a name="idd1e81845"></a><a name="idd1e81850"></a><a name="idd1e81855"></a><a name="idd1e81860"></a>A program such as the <tt>cron</tt> daemon has to fetch the current time every minute, as well as to set its first sleep period so that it wakes up at the beginning of the next minute. (Convert the current time to the local time and look at the <tt>tm_sec</tt> value.) Every minute, it sets the next sleep period so that it'll wake up at the next minute. Most of the calls will probably be <tt>sleep(60)</tt>, with an occasional <tt>sleep(59)</tt> to resynchronize with the next minute. But if at some point the process takes a long time executing commands or if the system gets heavily loaded and scheduling delays hold up the process, the sleep value can be much less than 60.</P></td></TR><TR valign="top"><td align="right" class="docText" width="50"><a name="ch10qa1q11a11"></a><B><a class="docLink" href="ch10lev1sec23.html#ch10qa1q11">10.11</a></b></TD><td><p class="docText">Under Linux 2.4.22 and Solaris 9, the signal handler for <tt>SIGXFSZ</tt> is never called. But <tt>write</tt> returns a count of 24 as soon as the file's size reaches 1,024 bytes.</p>
<p class="docText">When the file's size has reached 1,000 bytes under FreeBSD 5.2.1 and Mac OS X 10.3, the signal handler is called on the next attempt to write 100 bytes, and the <tt>write</tt> call returns 1 with <tt>errno</tt> set to <tt>EFBIG</tt> (&quot;File too big&quot;).</p></td></TR><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch10qa1q12a12"></a><b><a class="docLink" href="ch10lev1sec23.html#ch10qa1q12">10.12</a></b></TD><td><p class="docText">The results depend on the implementation of the standard I/O library: how the <tt>fwrite</tt> function handles an interrupted <tt>write</tt>.</p></td></tr></table></p>

<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/team.gif" width="60" height="17" border="0" align="absmiddle"  alt="Team BBL"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="app03lev1sec9.html"><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<a href="app03lev1sec11.html"><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>