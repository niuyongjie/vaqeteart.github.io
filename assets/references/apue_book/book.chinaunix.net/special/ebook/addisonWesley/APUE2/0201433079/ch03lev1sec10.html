<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 3.10.&nbsp; File Sharing</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/team.gif" width="60" height="17" border="0" align="absmiddle"  alt="Team BBL"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="ch03lev1sec9.html"><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<a href="ch03lev1sec11.html"><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch03lev1sec10"></a>
<h3 class="docSection1Title">3.10. File Sharing</h3>
<p class="docText">The UNIX System supports the sharing of open files among different processes. Before describing the <tt>dup</tt> function, we need to describe this sharing. To do this, we'll examine the data structures used by the kernel for all I/O.</P>
<blockquote>
<p class="docText">The following description is conceptual. It may or may not match a particular implementation. Refer to Bach [<a class="docLink" href="bib01.html#biblio01_013">1986</a>] for a discussion of these structures in System V. McKusick et al. [<a class="docLink" href="bib01.html#biblio01_042">1996</a>] describes these structures in 4.4BSD. McKusick and Neville-Neil [<a class="docLink" href="bib01.html#biblio01_043">2005</a>] cover FreeBSD 5.2. For a similar discussion of Solaris, see Mauro and McDougall [<a class="docLink" href="bib01.html#biblio01_044">2001</a>].</P>
</blockquote>
<p class="docText"><a name="idd1e20391"></a><a name="idd1e20396"></a><a name="idd1e20399"></a><a name="idd1e20402"></a><a name="idd1e20405"></a><a name="idd1e20408"></a><a name="idd1e20411"></a><a name="idd1e20414"></a>The kernel uses three data structures to represent an open file, and the relationships among them determine the effect one process has on another with regard to file sharing.</p>
<div style="font-weight:bold"><ol class="docList" type="1"><LI><div style="font-weight:normal"><p class="docList">Every process has an entry in the process table. Within each process table entry is a table of open file descriptors, which we can think of as a vector, with one entry per descriptor. Associated with each file descriptor are</P><div style="font-weight:bold"><ol class="docList" type="a"><LI><div style="font-weight:normal"><p class="docList">The file descriptor flags (close-on-exec; refer to <a class="docLink" href="ch03lev1sec10.html#ch03fig06">Figure 3.6</a> and <a class="docLink" href="ch03lev1sec14.html#ch03lev1sec14">Section 3.14</a>)</p></div></LI><LI><div style="font-weight:normal"><p class="docList">A pointer to a file table entry</P></div></li></ol></div></div></LI><li><div style="font-weight:normal"><p class="docList">The kernel maintains a file table for all open files. Each file table entry contains</P><div style="font-weight:bold"><ol class="docList" type="a"><LI><div style="font-weight:normal"><p class="docList">The file status flags for the file, such as read, write, append, sync, and nonblocking; more on these in <a class="docLink" href="ch03lev1sec14.html#ch03lev1sec14">Section 3.14</a></P></div></li><LI><div style="font-weight:normal"><p class="docList">The current file offset</P></div></li><LI><div style="font-weight:normal"><p class="docList">A pointer to the v-node table entry for the file</P></div></li></ol></div></div></li><li><div style="font-weight:normal"><p class="docList">Each open file (or device) has a v-node structure that contains information about the type of file and pointers to functions that operate on the file. For most files, the v-node also contains the i-node for the file. This information is read from disk when the file is opened, so that all the pertinent information about the file is readily available. For example, the i-node contains the owner of the file, the size of the file, pointers to where the actual data blocks for the file are located on disk, and so on. (We talk more about i-nodes in <a class="docLink" href="ch04lev1sec14.html#ch04lev1sec14">Section 4.14</a> when we describe the typical UNIX file system in more detail.)</p><blockquote>
<p class="docText">Linux has no v-node. Instead, a generic i-node structure is used. Although the implementations differ, the v-node is conceptually the same as a generic i-node. Both point to an i-node structure specific to the file system.</P>
</blockquote></div></li></ol></div>
<p class="docText">We're ignoring some implementation details that don't affect our discussion. For example, the table of open file descriptors can be stored in the user area instead of the process table. These tables can be implemented in numerous waysthey need not be arrays; they could be implemented as linked lists of structures, for example. These implementation details don't affect our discussion of file sharing.</P>
<p class="docText"><a class="docLink" href="ch03lev1sec10.html#ch03fig06">Figure 3.6</a> shows a pictorial arrangement of these three tables for a single process that has two different files open: one file is open on standard input (file descriptor 0), and the other is open on standard output (file descriptor 1). The arrangement of these three tables has existed since the early versions of the UNIX System [<a class="docLink" href="bib01.html#biblio01_064">Thompson 1978</a>], and this arrangement is critical to the way files are shared among processes. We'll return to this figure in later chapters, when we describe additional ways that files are shared.</p>
<a name="ch03fig06"></a><P><center>
<h5 class="docFigureTitle">Figure 3.6. Kernel data structures for open files</h5>
<p class="docText"><div class="v1"><a target="_self" href="images/0201433079/graphics/03fig06_alt.gif;423615">[View full size image]</a></div><img border="0" alt="" id="195131139046" width="500" height="195" SRC="images/0201433079/graphics/03fig06.gif;423615"></p>
</center></p><br>
<blockquote>
<p class="docText">The v-node was invented to provide support for multiple file system types on a single computer system. This work was done independently by Peter Weinberger (Bell Laboratories) and Bill Joy (Sun Microsystems). Sun called this the Virtual File System and called the file systemindependent portion of the i-node the v-node [<a class="docLink" href="bib01.html#biblio01_030">Kleiman 1986</a>]. The v-node propagated through various vendor implementations as support for Sun's Network File System (NFS) was <a name="idd1e20509"></a><a name="idd1e20514"></a><a name="idd1e20519"></a><a name="idd1e20524"></a><a name="idd1e20527"></a><a name="idd1e20532"></a><a name="idd1e20535"></a><a name="idd1e20538"></a>added. The first release from Berkeley to provide v-nodes was the 4.3BSD Reno release, when NFS was added.</p>
<p class="docText">In SVR4, the v-node replaced the file systemindependent i-node of SVR3. Solaris is derived from SVR4 and thus uses v-nodes.</p>
<p class="docText">Instead of splitting the data structures into a v-node and an i-node, Linux uses a file systemindependent i-node and a file systemdependent i-node.</p>
</blockquote>
<p class="docText">If two independent processes have the same file open, we could have the arrangement shown in <a class="docLink" href="ch03lev1sec10.html#ch03fig07">Figure 3.7</a>. We assume here that the first process has the file open on descriptor 3 and that the second process has that same file open on descriptor 4. Each process that opens the file gets its own file table entry, but only a single v-node table entry is required for a given file. One reason each process gets its own file table entry is so that each process has its own current offset for the file.</p>
<a name="ch03fig07"></a><p><center>
<h5 class="docFigureTitle">Figure 3.7. Two independent processes with the same file open</h5>
<p class="docText"><div class="v1"><a target="_self" href="images/0201433079/graphics/03fig07_alt.gif;423615">[View full size image]</a></div><img border="0" alt="" id="195131139046" width="500" height="393" SRC="images/0201433079/graphics/03fig07.gif;423615"></p>
</center></p><br>
<p class="docText">Given these data structures, we now need to be more specific about what happens with certain operations that we've already described.</p>
<ul><LI><p class="docList">After each <tt>write</tt> is complete, the current file offset in the file table entry is incremented by the number of bytes written. If this causes the current file offset to exceed the current file size, the current file size in the i-node table entry is set to the current file offset (for example, the file is extended).</P></li><LI><p class="docList">If a file is opened with the <tt>O_APPEND</tt> flag, a corresponding flag is set in the file status flags of the file table entry. Each time a <tt>write</tt> is performed for a file with this append flag set, the current file offset in the file table entry is first set to the current file size from the i-node table entry. This forces every <tt>write</tt> to be appended to the current end of file.</P></LI><li><p class="docList">If a file is positioned to its current end of file using <tt>lseek</tt>, all that happens is the current file offset in the file table entry is set to the current file size from the i-node table entry. (Note that this is not the same as if the file was opened with the <tt>O_APPEND</tt> flag, as we will see in <a class="docLink" href="ch03lev1sec11.html#ch03lev1sec11">Section 3.11</a>.)</P></LI><LI><p class="docList"><a name="idd1e20623"></a><a name="idd1e20628"></a><a name="idd1e20633"></a>The <tt>lseek</tt> function modifies only the current file offset in the file table entry. No I/O takes place.</p></LI></ul>

<p class="docText">It is possible for more than one file descriptor entry to point to the same file table entry, as we'll see when we discuss the <tt>dup</tt> function in <a class="docLink" href="ch03lev1sec12.html#ch03lev1sec12">Section 3.12</a>. This also happens after a <tt>fork</tt> when the parent and the child share the same file table entry for each open descriptor (<a class="docLink" href="ch08lev1sec3.html#ch08lev1sec3">Section 8.3</a>).</P>
<p class="docText">Note the difference in scope between the file descriptor flags and the file status flags. The former apply only to a single descriptor in a single process, whereas the latter apply to all descriptors in any process that point to the given file table entry. When we describe the <tt>fcntl</tt> function in <a class="docLink" href="ch03lev1sec14.html#ch03lev1sec14">Section 3.14</a>, we'll see how to fetch and modify both the file descriptor flags and the file status flags.</P>
<p class="docText">Everything that we've described so far in this section works fine for multiple processes that are reading the same file. Each process has its own file table entry with its own current file offset. Unexpected results can arise, however, when multiple processes write to the same file. To see how to avoid some surprises, we need to understand the concept of atomic operations.</P>

<ul></UL></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/team.gif" width="60" height="17" border="0" align="absmiddle"  alt="Team BBL"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="ch03lev1sec9.html"><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<a href="ch03lev1sec11.html"><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>