---
layout: posts
title: Vim实践与学习-06编程
categories: [categories, study, vim]
tags: [gtd_next, study]
comments: true
---

这里的内容是针对编程序或者阅读源代码时候使用的，本来它的有些内容可以属于其它类的，但是这里单独用"编程相关"将这类命令集中起来了。


* 编译并自动定位第一个错误：  
输入`:make filename`。  
注意：在vi中编译test.c,直接用`:make test`就可以了,注意是不带后缀的哟。如果有makefile的话可以再vi直接敲`:make`，然后就能够定位到第一个错误上面了。

* 关于ctags跳转：  
    通常我们需要使用名为ctags的程序来生成这样的tag文件。vim能直接使用ctags程序所生成的tag文件。  

    + 安装ctags：  
            
            $sudo apt-get install ctags
        注意这里是在ubuntu下。


    + 为当前目录文件生成tags文件：  

            $ctags -R ./
        或  

            $ctags -R
        这里，如果`ctags -R ../`将会也生成父目录文件的tags，ctags利用tags进行跳转。


    + 载入当前标签：  
        输入`:set tags=tags`.    
        这将载入（当前目录的）所需标签文件，如果不载入则没有ctags所需要的tags文件，为了实现自动载入启动可以在~/.vimrc加入如下内容：  

            if has("ctags")
                if filereadable("tags")
                    set tags=tags
                endif
            endif

    + 直接打开文件并跳转到函数:  
            $vim -t func
        这样，将打开vim并且直接跳转到func函数的位置。


    + 跳转到当前光标函数实现内部：  
        输入`[Ctrl]]`.    
        实现这个功能需要有tags标签。


    + 回到[Ctrl][之前的位置：  
        输入`[Ctrl]T`.      
        这里，应该是`[Ctrl]]`之前的位置，有待修改。


    + 分割一个窗口并跳转到当前光标函数实现内部：    
        输入`[Ctrl]w ]`.  

    + 跳转到指定函数实现处：  
        输入`:tag func`.  
        或输入`:tselect func`  
        这样将跳到func函数的实现地方,tag func如果有多个将自动跳到第1个,tselect func如果多个则显示一个所有匹配列表，让你选择哪个。这里标签名可以用[Tab]进行命令补全.

    + 新开一个窗口，查看tag的函数：  
        输入`:stag tagname`.  
        这里，tagname是一个tag标签（例如函数名）效果相当于首先用:split，再用tag tagname.窗口是水平的。  
        如果有多个tag匹配则：  

        - 切换到下一个匹配标签处：  
            输入`:tnext`

        - 切换到上一个匹配标签处：  
            输入`:tprev`

        - 切换到第一个匹配标签处：  
            输入`:tfirst`

        - 切换到最后一个匹配标签处：  
            输入`:tlast`

        - 显示所有匹配标签:  
            输入`:tags`

        - 显示所有匹配标签并让你选择指定的：  
            输入`:tselect`。

* 关于代码折叠  
    + 设置可以折叠  
        输入`:set fdm=syntax`.  
        或输入`:set fdm=indent`.  
        这里，fdm实际上是foldmethod的简写,第1个syntax方式是按照语法进行折叠（我倾向用这个所以后面都是对这个方式折叠下的命令），第2个是对大括号内的进行折叠。

    + 对当前代码块进行折叠：  
        输入`zc`.  
        这里，需要把当前光标放置到需要折叠的代码块的内部，因为一般程序结构都是嵌套的，这个命令折叠的是最内层的代码块。  

    + 对当前代码块所在范围代码块全部折叠：  
        输入`zC`.  
        这里，折叠的不仅仅是最内层的代码块了，而是连带着递归地折叠了包含该代码块的这个代码块。

    + 展开当前代码最外层折叠：  
        输入`zo`.  
        这里，是对光标下的折叠代码块最外层折叠进行打开，内层的折叠仍旧折叠着，除非你移动到那里再次用这个命令打开折叠，有时候你按一下左右方向键也会打开折叠。

    + 展开当前代码包含的所有折叠：  
        输入`zO`.  
        这里，展开的不仅仅是最外层的代码块了，而是连带着递归地展开了该代码块包含的所有内层代码块。

    + 折叠当前文件所有可能折叠的代码：  
        输入`zM`.  
        这样，将把当前文件的所有可以折叠的代码进行折叠。

    + 展开当前文件所有折叠的代码：  
        输入`zR`.  
        或输入`:set foldlevel=999`.  
        这样，将把当前文件的所有折叠的代码展开。

    + 全部展开或折叠当前文件所有可以折叠的代码：  
        输入`zi`.  
        这里，相当于zR和zM命令的“综合”，这个命令在全部折叠和全部展开两个命令之间进行“开关”切换。

    + 到当前打开的折叠的开始处:  
        输入`[z`.

    + 到当前打开的折叠的末尾处:  
        输入`]z`.

    + 跳到下一个折叠的开始处:  
        输入`zj`.  
        这里，关闭的折叠也被计入。

    + 跳到上一个折叠的末尾处:  
        输入`zk`.  
        这里，关闭的折叠也被计入。

* cscope的使用  
    + cscioe功能：  
    可以解决类似如下的问题：  
        1. 符号在哪里实用的？  
        2. 在哪里定义的？  
        3. 变量从哪里得到它的值的？  
        4. 全局变量的定义？  
        5. 这个函数在源代码中的什么文件中？  
        6. 什么函数调用了这个函数？  
        7. 这个函数调用了什么函数？  
        8. 消息“out of space”来自哪里？  
        9. 这个源文件在目录中的结构？  
        10. 哪些文件包含了这个头文件？  
  
    + 软件下载：  
        http://sourceforge.net/project/showfiles.php?group_id=4664   
  
    + 软件安装:  
        1. `./configure --with-flex` (注：如果平台是Linux,最好带上 `--with-flex`选项)   
        2. `make` (注：我没有遇到错误)  
        3. `make install` (注： 直接安装好了)  
  
    + cscope配置  
        修改vim配置文件vimrc.你可以修改/etc/vimrc使用所有用户都使用本配置文件，当然你还可以修改~/.vimrc   
        1. 下载cscope配置文件：cscope_map.vim  （http://cscope.sourceforge.net/cscope_maps.vim）  
        2. 把cscope_map.vim里从 if has("cscope")? 到 endif里边的内容复制到/etc/vimrc里边去   
        3. 里边的命令意思自己琢磨  
  
    + cscope相关命令  
        生成索引文件,在源代码目录中输入：`$cscope -Rb`  
        另外，有的时候：`$cscope -Rbkq<回车>`  
        这里，  
        R 表示把所有子目录里的文件也建立索引  
        b 表示cscope不启动自带的用户界面，而仅仅建立符号数据库  
        q生成cscope.in.out和cscope.po.out文件，加快cscope的索引速度  
        k在生成索引文件时，不搜索/usr/include目录  
        更多查看man.  
  
    + vim下的相关命令：  
        - 简单的帮助命令列表：  
        输入`:cs help`  
        或输入`:cs`  
        cs是cscope的简写命令，后面也是如此。  
  
        - 添加一个新的cscope数据库链接:  
        输入`:cs add cscope.out`  
        这样，把当前目录下面的cscope.out这个cscope数据文件添加了，就可以利用其中的内容了，如果没有链接数据库，那么就用不了相应的功能了。可以把这个命令加入到.vimrc中，省得人工输入。  
  
        - 查看当前已经链接的cscope数据库链接:  
        输入`:cs show`  
  
        - 查找相关命令：  
            1. 查找C语言符号，即查找函数名、宏、枚举值等出现的地方  
                输入`:cs find s <符号名>`.  
                或输入`cs f s <符号名>`.   
                这里,等价于`:cs find 0`.  
  
            2. 查找函数、宏、枚举等定义的位置，类似ctags所提供的功能:  
                输入`:cs find g <符号名>`.  
                或输入`cs f g <符号名>`.  
                这里,等价于`:cs find 1`.  
  
            3. 查找本函数调用的函数:  
                输入`:cs find d <符号名>`.  
                或输入`:cs f d <符号名>`.  
                这里,等价于`:cs find 2`.  
  
            4. 查找调用本函数的函数:  
                输入`:cs find c <符号名>`.  
                或输入`:cs f c <符号名>`.  
                这里,等价于`:cs find 3`.  
  
            5. 查找指定的字符串:  
                输入`:cs find t <符号名>`.  
                或输入`:cs f t <符号名>`.  
                这里等价于`:cs find 4`  
  
            6. 查找egrep模式，相当于egrep功能，但查找速度快多了:  
                输入`:cs find e <字符串>`.  
                或输入`:cs f e <字符串>`.  
                这里,等价于`:cs find 6`，注意没有5.  
  
            7. 查找并打开文件，类似vim的find功能:  
                输入`:cs find f <文件>`.  
                或输入`:cs f f <文件>`.  
                这里,等价于`:cs find 7`.  
  
            8. 查找包含本文件的文件:  
                输入`:cs find i <文件>`  
                这里等价于`:cs find 8`.  
                以上的`cs find`均可简写为`cs f`.  
  
        - 将cscope的数据库内容作为tags:  
            输入`:set cst`.  
            或输入`:set cscopetag`.  
            这样就 会把cscope的数据库当成tag文件了，在只有cscopt.out的情况下可以用[Ctrl]]进入相应的函数了。这样只用cscope不用ctags了。关闭这个功能是`:set nocst`.但是cscope无法在tag的时候自动不全标号，另外，cscope虽然搜索全局字符串似乎挺好，但是在用cscope的方式tag函数的时候，如果源文件修改了例如增加几个空行之类的，那么回出现定位错位，而ctags就不会。  
  
        - 察看光标下的函数:  
            输入`[Ctrl]\g`.  
            这里，是加入cscope.vim的相关语句到.vimrc中之后有的快捷键。cscope.vim内容在“其他相关“里面最后有列出了。  
  
        - 察看调用光标下函数的函数：  
            输入`[Ctrl]\c`.  
            还有其他等等，察看脚本内容就知道了，实际是`[Ctrl]\`等价于输入`:cs f`，之后输入相应的字符f,g,c等，就可以查找当前光标下标号的东西了。  
  
* 到当前局部变量的定义处:  
    输入`gd`.  
    这里，当前的意思是光标停留其上的单词。  
  
* 到当前全局变量的定义处:  
    输入`gD`.  
  
* 跳转到当前代码块的开头:  
    输入`[{`.  
    这里代码块一般是用`{}`扩起来的。  
  
* 查找在头文件中的某个相关定义：  
    输入`[Ctrl]w[Ctrl]i`.  
    这样，vim可以直接根据头文件进行查看，察看当前光标下的符号在头文件的相关定义。  
  
* 注释第1行到第20行:  
    输入`:1,20s/^/\/\//g`.  
    这里，`^`表示在行首插入,因为Vim/Vi替换命令格式中默认`/`为分隔符，这样就需要使用转义符`\`，表示`/`就要写成`\/`才可以，所以命令如上所示。强烈建议各位看官使用，省时省力省键盘还，如果shell的注释符号'#'就不用转义了。  
  
* 简单重排功能  
    + 当前行向右移一个shiftwidth:  
        输入` >>`.  
        这里， 整行会向右移一个 shiftwidth（预设是 8 个字元，可重设）。  
  
    + 当前行向左移一个shiftwidth:  
        输入` <<`.  
        这里， 整行会向左移一个 shiftwidth（预设是 8 个字元，可重设）。  
  
    + 将`{}`,`()`或`[]`等符号括起来的文本都右移:  
        输入`>%`.  
        这里,您必须把光标放在这些符号(`{}`,`()`或`[]`)上面.   
  
    + 将`{}`,`()`或`[]`等符号括起来的文本都左移:  
        输入`<%`.  
        这里,您必须把光标放在这些符号(`{}`,`()或`[]`)上面.   
  
    + 自动缩进选中代码的格式：  
        1. 输入`v`，  
        2. 移动光标，选择待调整的代码块，  
        3. 输入`=`。  
        这里，关键是先进入选择模式选择相应的代码，然后按‘＝’键，如果只按=就格式化当前行（需移动一下光标才看得出来）。  
  
* 打开一个预览窗口来显示函数 `write_char`：  
    输入`:ptag write_char`.  
    这样之后，光标会自动移动回原来的位置。窗口是水平的。  
  
* 关闭预览窗口：  
    输入`:pclose`.  
    这里，尽管当前光标不在预览窗口，也会关闭预览窗口。  
  
* 在预览窗口中编辑一个指定的文件:  
    输入 `:pedit `。  
    这在编辑头文件时很有用，这里的是要编辑的文件名,还可以同时定位到函数比如：`:pedit +/funcs defs.h`。这样可以在原有光标不变的情况下在预览窗口中修改。  
  
* 查找当前文件和任何包含文件中的单词并在预览窗口中显示匹配:  
    输入`psearch <函数名>`。  
    这在使用没有标签文件的库函数时十分有用。虽然它不是很智能，但是它能够到库头文件中搜索。  
  
* quickfix定位代码错误的使用  
    Quickfix模式的主要思想是保存一个位置列表，然后提供一系列命令，实现在这个位置列表中跳转。加快你的开发速度。  
    假设:你编写了一个程序，在vi中输入`:make`调用makefile来编译的时候程序中有错误，回车就会返回编辑界面（实际会自动定位到第一个错误）。运行如下命令可以定位错误：  
  
    + 显示并定位到第n个错误：  
        输入`:cc n`.  
        这样就会自动定位到第n个错误的位置，并显示相应的错误信息，如果没有n参数，就重现当前错误信息。  
  
    + 定位到当前错误的下一个错误处：  
        输入`:cn`.  
        这样如果当前在第n个错误的状态，这样会切换到第n+1个错误并定位到相应的位置。  
  
    + 定位到当前错误的上一个错误处：  
        输入`:cp`.  
        这样如果当前在第n个错误的状态，这样会切换到第n-1个错误并定位到相应的位置。  
  
    + 列出当前所有错误列表：  
        输入`:cl`.  
        这样列出一个错误列表，只是显示出了所有错误回车就又回到先前界面了。  
  
    + 在当前窗口底部打开一个quickfix窗口列出所有错误信息：  
        输入`:cw`.  
        这样会在当前窗口底部新开一个窗口，方便的看到所有错误信息，还可以把光标移动到相应的错误之处然后回车，就会回到代码窗口并定位到相应的错误位置。  
  
    + 回到上一个错误列表：  
        输入`:colder`.  
        或输入`:col`.  
        这样回到上一次的quickfix错误列表，例如再次编译还有错误，这个命令返回的是上次而不是这次的错误列表，运用cw等都是上次的错误信息。  
  
    + 进入较新的错误列表：  
        输入`:cnewer`.  
        或输入`:cnew`.  
        这个命令的作用和前面colder相反，进入更新的错误列表。  
  
* 关于自动补全：  
    + 显示自动补全列表：  
        输入`[Ctrl]p`  
        这里，是在插入模式下进行的，例如当前输入了`aa`字符，然后输入[Ctrl]p这样会列出所有以aa为开头的单词列表。它们会在当前缓冲区、其它缓冲区，以及当前文件所包含的头文件中查找以光标前关键字开始的单词。  
  
    + 选择自动补全列表中匹配的下一项：  
        输入`[Ctrl]n`.  
        这样如果有多个匹配的单词项那么会高亮下一项进行选择。如果不够则循环显示。  
  
    + 选择自动补全列表中匹配的上一项：  
        输入`[Ctrl]p`.  
        这样如果有多个匹配的单词项那么会高亮上一项进行选择。如果不够则循环显示。  
  
    + 自动匹配整个行：  
        输入`[Ctrl]x[Ctrl]l`.  
        这里，注意要在编辑状态下面运行的，会弹出文件中所有的整个行，之后用[Ctrl]p等就可以自动匹配了。  
        如果CTRL-N和CTRL-P补全时查找所包含的头文件，耗时会比较久。此时，可以在’complete‘选项中去掉'i'标记`:set complete-=i` 。  
